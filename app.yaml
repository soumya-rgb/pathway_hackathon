# This YAML configuration file is used to set up and configure the Adaptive RAG template.
# It defines various components such as data sources, language models, embedders, splitters, parsers, and retrievers.
# Each section is configured to specify how the template should process and handle data for generating responses.
# You can learn more about the YAML syntax here: https://pathway.com/developers/templates/configure-yaml



# $sources defines the data sources used to read the data which will be indexed in the RAG.
# You can learn more how to configure data sources here:
# https://pathway.com/developers/templates/yaml-examples/data-sources-examples

$sources:
  # File System connector, reading data locally.
  - !pw.io.fs.read
    path: data/Q5
    format: binary
    with_metadata: true
    post_processor: !pw.udfs.PythonLambda
      code: |
        def process(doc):
            # Assign topic based on folder or filename
            #doc.metadata["topic"] = doc.metadata.get("folder", "general")
            doc.metadata["topic"] = "electromagnetism"
            # Content type: lesson or quiz
            if "quiz" in doc.metadata.get("filename", "").lower():
                doc.metadata["content_type"] = "quiz"
            else:
                doc.metadata["content_type"] = "lesson"
            
            # Difficulty assignment based on filename
            fname = doc.metadata.get("filename", "").lower()
            if "easy" in fname:
                doc.metadata["difficulty"] = "easy"
            elif "medium" in fname:
                doc.metadata["difficulty"] = "medium"
            elif "hard" in fname:
                doc.metadata["difficulty"] = "hard"
            else:
                doc.metadata["difficulty"] = "medium"  # default
            
            '''doc.metadata["student_mastery"] = {
                "student_1": 0.5,
                "student_2": 0.8
            }'''
            doc.metadata["student_mastery_student_1"] = 0.5
            doc.metadata["student_mastery_student_2"] = 0.8
            
            print("Indexed document metadata:", doc.metadata)  #prints the metadat of doc
            return doc

  # Uncomment to use the SharePoint connector
  # To Create SharePoint credentials, refers to: https://pathway.com/developers/api-docs/pathway-xpacks-sharepoint/#pathway.xpacks.connectors.sharepoint.read
  # For More details on the configuration, refer to: https://pathway.com/developers/user-guide/connect/pathway-connectors
  # - !pw.xpacks.connectors.sharepoint.read 
  #   url: $SHAREPOINT_URL
  #   tenant: $SHAREPOINT_TENANT
  #   client_id: $SHAREPOINT_CLIENT_ID
  #   cert_path: sharepointcert.pem
  #   thumbprint: $SHAREPOINT_THUMBPRINT
  #   root_path: $SHAREPOINT_ROOT
  #   with_metadata: true
  #   refresh_interval: 30

  # Uncomment to use the Google Drive connector
  # TO Create Google Drive credentials, refers to: https://pathway.com/developers/user-guide/connect/connectors/gdrive-connector/
  # For More details on the configuration, refer to: https://pathway.com/developers/user-guide/connect/pathway-connectors
  # - !pw.io.gdrive.read
  #   object_id: $DRIVE_ID
  #   service_user_credentials_file: gdrive_indexer.json
  #   file_name_pattern:
  #     - "*.pdf"
  #     - "*.pptx"
  #   object_size_limit: null
  #   with_metadata: true
  #   refresh_interval: 30



# Configures the LLM model settings for generating responses.
# The list of available Pathway LLM wrappers is available here:
# https://pathway.com/developers/api-docs/pathway-xpacks-llm/llms
# You can learn more about those in our documentation:
# https://pathway.com/developers/templates/rag-customization/llm-chats

# Wrapper for OpenAI
# $llm: !pw.xpacks.llm.llms.OpenAIChat
#   model: "gpt-3.5-turbo"
#   retry_strategy: !pw.udfs.ExponentialBackoffRetryStrategy
#     max_retries: 6
#   cache_strategy: !pw.udfs.DiskCache
#   temperature: 0.05
#   capacity: 8

# for other models look in documentation LiteLLMChat
$llm: !pw.xpacks.llm.llms.LiteLLMChat
  model: "gemini/gemini-2.5-flash"
  retry_strategy: !pw.udfs.ExponentialBackoffRetryStrategy
    max_retries: 6
  cache_strategy: !pw.udfs.DefaultCache {}
  temperature: 0
  capacity: 8

# Specifies the embedder model for converting text into embeddings.
# can use OpenAIEmbedder also but requires API_KEY

# $embedder: !pw.xpacks.llm.embedders.OpenAIEmbedder
#   model: "text-embedding-ada-002"
#   cache_strategy: !pw.udfs.DiskCache

$embedder: !pw.xpacks.llm.embedders.GeminiEmbedder
  model: "gemini-embedding-001"
  cache_strategy: !pw.udfs.DefaultCache {}

# Defines the splitter settings for dividing text into smaller chunks.
$splitter: !pw.xpacks.llm.splitters.TokenCountSplitter
  max_tokens: 400

# Configures the parser for processing and extracting information from documents. more parser available checkout https://pathway.com/developers/user-guide/llm-xpack/parsers/
$parser: !pw.xpacks.llm.parsers.DoclingParser
  cache_strategy: !pw.udfs.DefaultCache {}

# Sets up the retriever factory for indexing and retrieving documents.
$retriever_factory: !pw.stdlib.indexing.BruteForceKnnFactory
  reserved_space: 1000
  embedder: $embedder
  metric: !pw.stdlib.indexing.BruteForceKnnMetricKind.COS

# Manages the storage and retrieval of documents for the RAG template.
$document_store: !pw.xpacks.llm.document_store.DocumentStore
  docs: $sources
  parser: $parser
  splitter: $splitter
  retriever_factory: $retriever_factory

# Configures the question-answering component using the RAG approach.
# The component builds a RAG over an index.
# You can interact with obtained RAG using a REST API.
# You can learn more about the available operations here:
# https://pathway.com/developers/templates/rag-customization/rest-api
question_answerer: !pw.xpacks.llm.question_answering.AdaptiveRAGQuestionAnswerer
  llm: $llm
  indexer: $document_store
  n_starting_documents: 2
  factor: 2
  max_iterations: 4

# Change host and port of the webserver by uncommenting these lines
# windows user if you change port change, make to map wiht right port, in docker command 
host: "0.0.0.0"
port: 8000

# Activate on-disk caching for UDFs for which `cache_strategy` is set
with_cache: true

# If `terminate_on_error` is true then the program will terminate whenever any error is encountered.
# Defaults to false, uncomment the following line if you want to set it to true
# terminate_on_error: true
